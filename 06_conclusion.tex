\section{Conclusion}
% \ninanotes{
% \begin{itemize}
% \item Conclusion
% \item What has been reached, how does the product work?
% \item What was not achieved or achieved exceeding the plan?
% \item Did you learn something new, techniques, socially?
% \item If there was more time . . .
% \item Personally, I . . . . . .
% \end{itemize}
% }

I have made a product based on modal logic, in which each agent can deduce a big set of possibilites for the other agents (and itself), and it is able to look through each possible world to extract some property about each world. It can currently only deduce what is possible for ones own hand, and in the case that it somehow knows that a scenario leads to an "empty" possible world for another player, then that world is not possible. However there are currently no way for it to know this. Furthermore it lacks is epistemic queries like: What is common knowledge? Common knowledge can be very useful when developing strategies since it can help them plan better when they target cards in \cite{CoxEtAl2015} information strategy. The modifications I made to the more general \KTfourfiveN leads to these type of queries are harder, since they are very strictly for a specific player's point of view. 
The model I made has a compact array structure, which is nice for algorithms which look through each possible world.
The current implementation has an average score of XX, which is far from the near-perfect strategies described in the introduction. The knowledge system I implement is orthogonal to most rule-based strategies, which means that you can take any rule-based strategy and incorporate the model in order to get better results.

If there was more time an obvious idea would be to try to use the information-strategy described in \cite{CoxEtAl2015} as well as the "recommendation strategy" in combinations with my modal logic model, because each of these strategies also tell you something about the possible worlds, and therefore they can be used to eliminate possible worlds from a players knowledge base.

If there was more time it would also be interesting to make a more general model, on which it would be possible to run "common knowledge" queries on \todo[inline]{Refer to the book on common knowledge queries}. As well as see if it would be possible to keep many of the benefits described in my model, like being mostly made of contiguous arrays, and fast iteration, compactness etc.  

If there was more time I would also like to look into how to optimize some aspects of the code, because right now there are a lot of redundant permutations \todo[inline]{refer to this in testing}, which unnecessary makes it spent more time trying to go through the possible worlds.

In this project I learned a lot about modal logic, which strikes me as a good balance between using a powerful type of logic, as well as being pretty realistic to implement and execute. Although I feel like I have only dipped my toes into the subject, and there is a lot more depths that I have yet to explore.

I also learned a lot about the programming language Zig, which has been a hobby-language of mine for quite a while, but I have not been able to test it on a project of this scale. Generally I would say that if you don't mind having to take responsibility for the memory, it is a language which gives a lot of power to a programmer who wants to experiment with data-representation and datastructures in general. Some aspects that would have been great to look into if I had more time would be multi-core programming using Zig, in order to optimize queries on the possible worlds.
